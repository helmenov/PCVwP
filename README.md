# v2 -> v3 の読み替え

- `print x`ではなく，`print(x)`

- パッケージ`PIL`は，ありません．現在はそのフォーク版パッケージ`pillow`になります．

- パッケージ`pylab`(MATLAB風python実装)は，ありません．
  - `pylab`の数値計算部分は，`numpy`が使われています．
  - `pylab`のグラフ表示部分は，`matplotlib`が使われています．

- インポートワイルドカード`*`は非推奨

    ```{.py}
    from pylab import *
    ```

    `pylab`のすべて（ワイルドカード`*`)のモジュールをインポートしていますが，ワイルドカード`*`は現在推奨されていません．

    ```{.py}
    import numpy as np
    from matplotlib import pyplot as plt
    ```
    のようにするのが一般的です．

    - `array()` --> `np.array()`
    - `imshow()` --> `plt.imshow()`
    - `plot()` --> `plt.plot()`
    - `title()` --> `plt.title()`
    - `show()` --> `plt.show()`

# ipythonでmatplotlibは最初のax.plot()で描画され，それ以降，セルを超えて上書きできない

画像の表示は，
1. キャンバス作成
    ```{.py}
    fig, ax = plt.figure()
    ```
2. キャンバスに画像やグラフを掲載
    ```{.py}
    ax.plot()
    ``` 
3. キャンバスを表示
    ```{.py}
    plt.show(fig)
    ```
の3つで成り立つ．

ipythonの場合は，画像表示をインライン(Non-GUI)で行われることになっており，3の`plt.show(fig)`は行うことができない．
その代わり，1の操作を行ったセルに対して出力セルに出力される．
注意として，2の操作は出力セルに画像を表示せず，あくまでキャンバスを内部更新するだけである．

したがって，ipythonの場合，1と2の操作が異なるセルで行われていると，1の操作のあるセルAで，画像表示がされ，2の操作のあるセルBには何も表示されないし，セルAで表示された画像が更新されて再表示されるわけでない．

もし，2の操作のあるセルBで，再度画像を表示したいなら，
```{.py}
ax.plot()
fig
```
と2の操作と同じセルで直後に`fig`を打つ．

